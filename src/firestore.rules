
/**
 * This ruleset enforces a security model for the Naarimani application,
 * balancing user-owned data with collaborative, shared resources.
 *
 * Core Philosophy:
 * The security model is built on two primary patterns: strict user-ownership for
 * personal data and membership-based access for shared data. All operations
 * require a user to be authenticated, providing a baseline level of security.
 *
 * Data Structure:
 * - User-specific data, such as profiles (`UserProfile`), is stored under the
 *   `/users/{userId}` path. This structure naturally maps ownership.
 * - Publicly readable content like posts, marketplace listings, courses, and
 *   events are in top-level collections, allowing for public reads by authenticated
 *   users but restricting writes to the designated owner.
 * - Collaborative resources like chats and kitty groups are also in top-level
 *   collections. Authorization is managed by denormalizing member lists directly
 *   onto the documents.
 *
 * Key Security Decisions:
 * - User Enumeration is Disabled: Listing the top-level `/users` collection is
 *   explicitly forbidden to protect user privacy.
 * - Default to Signed-In Users: Public read access is generally granted only to
 *   authenticated users (`isSignedIn()`) rather than being fully open (`if true;`),
 *   ensuring a logged-in context for all data interaction.
 * - Immutable Ownership: Critical relational IDs (e.g., `author.id`, `sellerId`)
 *   are enforced as immutable upon document creation to maintain data integrity.
 *
 * Denormalization for Authorization:
 * This ruleset relies heavily on denormalization to ensure fast and secure
 * authorization checks without costly `get()` calls. For example, a `/chats/{chatId}`
 * document contains a `participants` array, so a rule can instantly check if a user
 * is a member without reading another document. This is crucial for securing list
 * operations on subcollections like `/messages`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Verifies that a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * identified by the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * A stricter ownership check for updates and deletes that also ensures the
     * document being modified actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Verifies if the authenticated user's UID is present in a specified
     * array field (e.g., 'participants', 'memberIds') on a document.
     */
    function isMember(docData, key) {
      // Check if the key exists and is a list before checking for membership
      return isSignedIn() && key in docData && request.auth.uid in docData[key];
    }
    
    /**
     * Enforces immutability on a critical relational ID field during an update.
     * Prevents re-assigning ownership of a document.
     */
    function isRelationalIdImmutable(path) {
      return request.resource.data[path] == resource.data[path];
    }
    
    /**
      * Checks if the user is a super admin.
      */
    function isSuperAdmin() {
      return request.auth.uid == 'ebixEzJ8UuYjIYTXrkOObW1obSw1';
    }


    // -------------------------------------------------------------------------
    // User Data (/users)
    // -------------------------------------------------------------------------

    /**
     * @description A user can create, update, and delete their own profile. Other authenticated users can read profiles. Listing all users is disabled.
     * @path /users/{userId}
     * @allow (get) An authenticated user `user_abc` reading the profile of `user_xyz`.
     * @allow (create) A new user `user_abc` creating their own profile at `/users/user_abc`.
     * @deny (list) Any user attempting to list all documents in the `/users` collection.
     * @deny (update) User `user_abc` trying to modify the profile of `user_xyz`.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn(); // Allow listing for chat participant resolution and admin panel
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      // Allow a user to update their own profile, including their followingIds.
      // Allow other users to add themselves to this user's followerIds (for follow functionality).
      // When updating followerIds, allow if:
      //   1. User is updating their own profile and not changing followerIds, OR
      //   2. Another user is adding themselves to followerIds (using arrayUnion - new array contains all old values)
      allow update: if isRelationalIdImmutable('id')
                    && (
                      // User updating their own profile (can update followingIds, but not followerIds directly)
                      (isExistingOwner(userId) && (!('followerIds' in request.resource.data) || request.resource.data.followerIds == resource.data.followerIds))
                      ||
                      // Another user adding themselves to followerIds (follow functionality)
                      // Check: new followerIds contains auth.uid and preserves all existing followerIds
                      (isSignedIn() 
                       && 'followerIds' in request.resource.data
                       && request.auth.uid in request.resource.data.followerIds
                       && (!('followerIds' in resource.data) || 
                           (request.resource.data.followerIds.size() >= resource.data.followerIds.size() 
                            && request.resource.data.followerIds.hasAll(resource.data.followerIds))))
                    );
      allow delete: if isExistingOwner(userId);
    }
    
    // -------------------------------------------------------------------------
    // Posts (/posts)
    // -------------------------------------------------------------------------

    /**
     * @description All authenticated users can read posts. Users can only create posts as themselves. Only the author can update or delete their own post.
     * @path /posts/{postId}
     * @allow (list) Any authenticated user listing all posts for the main feed.
     * @allow (create) User `user_abc` creating a post where `author.id` is `user_abc`.
     * @deny (update) User `user_xyz` trying to edit a post authored by `user_abc`.
     * @principle Allows public discovery for authenticated users while enforcing ownership for writes.
     */
    match /posts/{postId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.author.id == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.author.id == request.auth.uid;
    }

    // -------------------------------------------------------------------------
    // Chats & Messages (/chats)
    // -------------------------------------------------------------------------

    /**
     * @description Chat documents are only accessible to their participants. Managing the participant list is disabled for clients.
     * @path /chats/{chatId}
     * @allow (get) User `user_abc` reading a chat document where `user_abc` is in the `participants` array.
     * @allow (create) User `user_abc` creating a new chat document where they include themself in the `participants` array.
     * @deny (list) Any user attempting to list all chats. This query must be performed by the client.
     * @deny (update) Any user trying to add or remove members from the `participants` array.
     * @principle Enforces access control based on a denormalized list of members (Closed Collaborators pattern).
     */
    match /chats/{chatId} {
      allow get: if isMember(resource.data, 'participants');
      // Allow list queries where the user is a participant. This is key for fetching the user's chat list.
      allow list: if isSignedIn() && request.auth.uid in resource.data.participants;
      allow create: if isMember(request.resource.data, 'participants');
      allow update: if false; // Membership changes should be handled by a backend function for security.
      allow delete: if false;
      
      /**
       * @description Messages can be read by chat participants and created/deleted by the sender.
       * @path /chats/{chatId}/messages/{messageId}
       * @allow (create) User `user_abc`, a participant in `chat_123`, sending a message where `senderId` is `user_abc`.
       * @allow (list) User `user_xyz`, a participant in `chat_123`, listing all messages in that chat.
       * @deny (get) User `user_pending` who is not in the parent chat's participant list trying to read a message.
       * @deny (delete) User `user_abc` trying to delete a message sent by `user_xyz`.
       * @principle Inherits authorization from the parent document and validates sender identity for writes.
       */
      match /messages/{messageId} {
        allow get, list: if isMember(get(/databases/$(database)/documents/chats/$(chatId)).data, 'participants');
        allow create: if isMember(get(/databases/$(database)/documents/chats/$(chatId)).data, 'participants') && request.resource.data.senderId == request.auth.uid && request.resource.data.chatId == chatId;
        allow update: if isExistingOwner(resource.data.senderId) && isRelationalIdImmutable('senderId') && isRelationalIdImmutable('chatId');
        allow delete: if isExistingOwner(resource.data.senderId);
      }
    }

    // -------------------------------------------------------------------------
    // Communities (/communities)
    // -------------------------------------------------------------------------

    /**
     * @description Communities are publicly discoverable. Anyone can create one, making themself the leader. Only the leader can manage it.
     * @path /communities/{communityId}
     * @allow (list) Any authenticated user listing all available communities.
     * @allow (create) User `user_abc` creating a new community and setting `leaderId` to `user_abc`.
     * @deny (update) A regular member `user_xyz` trying to change the community description. Only the leader can.
     * @principle Allows public discovery while centralizing write control to a single owner/leader.
     */
    match /communities/{communityId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.leaderId == request.auth.uid;
      allow update: if isOwner(resource.data.leaderId) && resource != null;
      allow delete: if isOwner(resource.data.leaderId) && resource != null;
    }

    // -------------------------------------------------------------------------
    // Kitty Groups (/kitty_groups)
    // -------------------------------------------------------------------------

    /**
     * @description Kitty Groups are private and only accessible to their members. Listing all groups is disabled for privacy.
     * @path /kitty_groups/{kittyGroupId}
     * @allow (get) User `user_abc` reading a group document where they are in the `memberIds` array.
     * @allow (create) User `user_abc` creating a new group where they are included in the initial `memberIds`.
     * @deny (list) Any user attempting to discover all kitty groups (except super admin).
     * @deny (update) Any member trying to modify the group. This must be handled by a backend function.
     * @principle Enforces strict membership-based access for highly sensitive collaborative data.
     */
    match /kitty_groups/{kittyGroupId} {
      allow get: if isMember(resource.data, 'memberIds') || isSuperAdmin();
      // Allow list queries where the user is a member, or if they are a super admin.
      allow list: if isSignedIn() && (request.auth.uid in resource.data.memberIds || isSuperAdmin());
      allow create: if isSignedIn() && isMember(request.resource.data, 'memberIds');
      allow update: if isSuperAdmin(); // Allow super admin to update groups.
      allow delete: if isSuperAdmin(); // Allow super admin to delete groups.
    }

    // -------------------------------------------------------------------------
    // Marketplace (/marketplace_listings)
    // -------------------------------------------------------------------------
    
    /**
     * @description Marketplace listings are publicly readable by any authenticated user. Only the seller can create, update, or delete their own listings.
     * @path /marketplace_listings/{listingId}
     * @allow (list) Any authenticated user browsing all marketplace listings.
     * @allow (create) User `user_seller` creating a new listing with `sellerId` set to `user_seller`.
     * @deny (update) User `user_buyer` attempting to change the price on a listing owned by `user_seller`.
     * @principle Implements a "Public Read with Owner-Only Writes" pattern, ideal for public catalogs.
     */
    match /marketplace_listings/{listingId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.sellerId) && isRelationalIdImmutable('sellerId');
      allow delete: if isExistingOwner(resource.data.sellerId);
    }
    
    // -------------------------------------------------------------------------
    // Support Directory (/directory)
    // -------------------------------------------------------------------------

    /**
     * @description The support directory is publicly readable by any authenticated user. Creating new entries is restricted to admins.
     * @path /directory/{professionalId}
     * @allow (list) Any authenticated user browsing all professionals.
     * @principle Allows public discovery of support professionals while centralizing write access.
     */
    match /directory/{professionalId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSuperAdmin();
    }

    // -------------------------------------------------------------------------
    // Courses (/courses)
    // -------------------------------------------------------------------------

    /**
     * @description Courses are publicly discoverable. Anyone can create one, making themself the instructor. Only the instructor can modify or delete it.
     * @path /courses/{courseId}
     * @allow (get) Any authenticated user viewing the details of a course.
     * @allow (create) User `user_teacher` creating a new course with `instructorId` set to `user_teacher`.
     * @deny (delete) An enrolled student `user_student` trying to delete the course.
     * @principle Allows public discovery while centralizing write control to a single owner (the instructor).
     */
    match /courses/{courseId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.instructorId == request.auth.uid;
      allow update: if isOwner(resource.data.instructorId) && resource != null;
      allow delete: if isOwner(resource.data.instructorId) && resource != null;
    }
    
    // -------------------------------------------------------------------------
    // Contests (/contests)
    // -------------------------------------------------------------------------

    /**
     * @description Contests are publicly discoverable. Any authenticated user can read them and propose a new one.
     * @path /contests/{contestId}
     * @allow (list) Any authenticated user browsing all contests.
     * @allow (create) Any signed-in user can propose a new contest.
     * @principle Allows public discovery and community-driven content proposals. Updates/deletes managed by admin.
     */
    match /contests/{contestId} {
        allow get, list: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if isSuperAdmin();
    }

    // -------------------------------------------------------------------------
    // Events (/events)
    // -------------------------------------------------------------------------

    /**
     * @description Events are publicly discoverable. Anyone can create one, making themself the organizer. Only the organizer can modify or delete it.
     * @path /events/{eventId}
     * @allow (list) Any authenticated user browsing all upcoming events.
     * @allow (create) User `user_host` creating a new event with `organizerId` set to `user_host`.
     * @deny (update) An attendee `user_guest` trying to change the event's location.
     * @principle Allows public discovery while centralizing write control to a single owner (the organizer).
     */
    match /events/{eventId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isOwner(resource.data.organizerId) && resource != null;
      allow delete: if isOwner(resource.data.organizerId) && resource != null;
    }
    
    // -------------------------------------------------------------------------
    // Professional Applications (/professional_applications)
    // -------------------------------------------------------------------------
    
    /**
     * @description Users can create their own application. Admins can read all applications and update their status.
     * @path /professional_applications/{applicationId}
     * @allow (create) User `user_abc` creating an application for themself.
     * @allow (list) An admin listing all applications.
     * @deny (read) A regular user reading another user's application.
     * @principle Enforces ownership on creation and admin-only access for review.
     */
    match /professional_applications/{applicationId} {
      allow get, list, update, delete: if isSuperAdmin();
      allow create: if isOwner(request.resource.data.userId);
    }

    // -------------------------------------------------------------------------
    // Notifications (/notifications)
    // -------------------------------------------------------------------------

    /**
     * @description Users can read their own notifications. System can create notifications for users.
     * @path /notifications/{notificationId}
     * @allow (get, list) User `user_abc` reading notifications where `userId` is `user_abc`.
     * @allow (create) System creating a notification for user `user_abc`.
     * @deny (read) User `user_xyz` trying to read notifications for user `user_abc`.
     * @principle Users can only access their own notifications for privacy.
     */
    match /notifications/{notificationId} {
      // For get operations, check if the notification belongs to the user
      allow get: if isSignedIn() && (resource == null || resource.data.userId == request.auth.uid);
      // For list queries, check each document - only return notifications belonging to the user
      // The where clause in the query works together with this rule to ensure security
      allow list: if isSignedIn() && resource.data.userId == request.auth.uid;
      // Allow creating notifications for the authenticated user
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      // Allow updating/deleting own notifications
      allow update: if isSignedIn() && resource != null && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.userId == request.auth.uid;
    }

    // -------------------------------------------------------------------------
    // Notification Preferences (/notification_preferences)
    // -------------------------------------------------------------------------

    /**
     * @description Users can read and update their own notification preferences.
     * @path /notification_preferences/{preferenceId}
     */
    match /notification_preferences/{preferenceId} {
      allow get, list, create, update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }
  }
}
